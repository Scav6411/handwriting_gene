# -*- coding: utf-8 -*-
"""tr_OCR.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12zh3RM3ZaXvN-MvT0005giADPRX-YU3g
"""
import torch
import torchvision.transforms as transforms
import numpy as np
from transformers import TrOCRProcessor, VisionEncoderDecoderModel
from PIL import Image
import zipfile
import os
batch_size = 8
DEVICE = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
class ImageProcessor():
    def __init__(self):
        self.processor = TrOCRProcessor.from_pretrained("microsoft/trocr-large-handwritten")
        self.model_trocr = VisionEncoderDecoderModel.from_pretrained("microsoft/trocr-large-handwritten").to(DEVICE)

    def process_images(self,ids):
        directory = '/content/Cropped_Images'
        iter= ids // batch_size
        image_dict = {}
        for i in range(batch_size):
          count=0
          for filename in os.listdir(directory):
            if(count<iter):
              if filename.endswith('.jpg') or filename.endswith('.png'):  # Adjust the file extensions as needed
                img_path = os.path.join(directory, filename)
                from PIL import Image

                # Open the image file
                image = Image.open(img_path)

                # Calculate the scale factor to maintain aspect ratio
                width, height = image.size
                # Resize the image with the new height while maintaining aspect ratio
                image = image.resize((width, 32))
                # image = image.resize((32,32))
                pixel_values = self.processor(image, return_tensors="pt").pixel_values
                pixel_values = pixel_values.to(DEVICE)
                generated_ids = self.model_trocr.generate(pixel_values)
                generated_text = self.processor.batch_decode(generated_ids, skip_special_tokens=True)[0]
                generated_text = generated_text[:-1]

                label=generated_text
                count=count+1
                entry = {'image': image, 'label': label}
                if str(i+1) in image_dict:
                  image_dict[str(i+1)].append(entry)
                else:
                  image_dict[str(i+1)] = [entry]
                  os.remove(img_path)
            else:
              break
        return image_dict